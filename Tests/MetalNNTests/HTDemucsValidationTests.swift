import XCTest
import Foundation
@testable import MetalNN
@testable import MetalAudioKit

// MARK: - HTDemucs PyTorch Validation Tests

/// Validates HTDemucs encoder blocks against PyTorch reference outputs.
///
/// Reference data is generated by `Scripts/generate_htdemucs_reference.py`.
/// Each test loads a JSON file with input, weights, and expected output from PyTorch,
/// then compares our Metal implementation against it.
@available(macOS 15.0, iOS 18.0, *)
final class HTDemucsValidationTests: XCTestCase {

    var device: AudioDevice!
    var context: ComputeContext!

    /// Absolute tolerance for float comparison
    /// With tanh GELU approximation in both PyTorch reference and Metal,
    /// we achieve ~1e-6 accuracy. Set to 1e-4 for safety margin.
    /// Main error sources:
    /// - Float32 precision limits
    /// - GPU vs CPU accumulation order differences
    let absoluteTolerance: Float = 1e-4

    /// Relative tolerance for float comparison
    let relativeTolerance: Float = 1e-3

    override func setUpWithError() throws {
        device = try AudioDevice()
        context = try ComputeContext(device: device)
    }

    // MARK: - Time Encoder Block Tests (1D)

    func testTimeEncoderLevel0() throws {
        try runTimeEncoderValidation(testName: "time_encoder_level0")
    }

    func testTimeEncoderLevel1() throws {
        try runTimeEncoderValidation(testName: "time_encoder_level1")
    }

    func testTimeEncoderLevel2() throws {
        try runTimeEncoderValidation(testName: "time_encoder_level2")
    }

    // MARK: - Freq Encoder Block Tests (2D)

    func testFreqEncoderLevel0() throws {
        try runFreqEncoderValidation(testName: "freq_encoder_level0")
    }

    func testFreqEncoderLevel1() throws {
        try runFreqEncoderValidation(testName: "freq_encoder_level1")
    }

    // MARK: - Time Encoder Validation Logic

    private func runTimeEncoderValidation(testName: String) throws {
        guard let testData = loadTestData(name: testName) else {
            throw XCTSkip("Reference data not found: \(testName).json")
        }

        let config = testData["config"] as! [String: Any]
        let inChannels = config["in_channels"] as! Int
        let outChannels = config["out_channels"] as! Int
        let kernelSize = config["kernel_size"] as! Int
        let stride = config["stride"] as! Int
        let numGroups = config["num_groups"] as! Int

        let inputShape = testData["input_shape"] as! [Int]
        let inputData = (testData["input"] as! [Double]).map { Float($0) }
        let convWeight = (testData["conv_weight"] as! [Double]).map { Float($0) }
        let convBias = (testData["conv_bias"] as! [Double]).map { Float($0) }
        let normWeight = (testData["norm_weight"] as! [Double]).map { Float($0) }
        let normBias = (testData["norm_bias"] as! [Double]).map { Float($0) }
        let expectedOutput = (testData["output"] as! [Double]).map { Float($0) }

        // Create time encoder block
        let blockConfig = UNetEncoderBlock.Config(
            inputChannels: inChannels,
            outputChannels: outChannels,
            kernelSize: kernelSize,
            stride: stride,
            numGroups: numGroups
        )
        let encoder = try UNetEncoderBlock(device: device, config: blockConfig)

        // Load weights
        try encoder.loadWeights(
            convWeight: convWeight,
            convBias: convBias,
            normWeight: normWeight,
            normBias: normBias
        )

        // Create input tensor
        let input = try Tensor(device: device, shape: inputShape)
        try input.copy(from: inputData)

        // Run forward pass
        var output: Tensor?
        try context.executeSync { encoder_cmd in
            let (out, _) = try encoder.forward(input: input, encoder: encoder_cmd)
            output = out
        }

        // Compare output
        let actualOutput = output!.toArray()
        compareArrays(
            expected: expectedOutput,
            actual: actualOutput,
            testName: testName
        )
    }

    // MARK: - Freq Encoder Validation Logic

    private func runFreqEncoderValidation(testName: String) throws {
        guard let testData = loadTestData(name: testName) else {
            throw XCTSkip("Reference data not found: \(testName).json")
        }

        let config = testData["config"] as! [String: Any]
        let inChannels = config["in_channels"] as! Int
        let outChannels = config["out_channels"] as! Int
        let kernelSize = config["kernel_size"] as! [Int]
        let stride = config["stride"] as! [Int]
        let numGroups = config["num_groups"] as! Int

        let inputShape = testData["input_shape"] as! [Int]
        let inputData = (testData["input"] as! [Double]).map { Float($0) }
        let convWeight = (testData["conv_weight"] as! [Double]).map { Float($0) }
        let convBias = (testData["conv_bias"] as! [Double]).map { Float($0) }
        let normWeight = (testData["norm_weight"] as! [Double]).map { Float($0) }
        let normBias = (testData["norm_bias"] as! [Double]).map { Float($0) }
        let expectedOutput = (testData["output"] as! [Double]).map { Float($0) }

        // Create 2D freq encoder block
        let blockConfig = FreqUNetEncoderBlock2D.Config(
            inputChannels: inChannels,
            outputChannels: outChannels,
            kernelSize: (height: kernelSize[0], width: kernelSize[1]),
            stride: (height: stride[0], width: stride[1]),
            numGroups: numGroups
        )
        let encoder = try FreqUNetEncoderBlock2D(device: device, config: blockConfig)

        // Load weights
        try encoder.loadWeights(
            convWeight: convWeight,
            convBias: convBias,
            normWeight: normWeight,
            normBias: normBias
        )

        // Create input tensor
        let input = try Tensor(device: device, shape: inputShape)
        try input.copy(from: inputData)

        // Run forward pass
        var output: Tensor?
        try context.executeSync { encoder_cmd in
            let (out, _) = try encoder.forward(input: input, encoder: encoder_cmd)
            output = out
        }

        // Compare output
        let actualOutput = output!.toArray()
        compareArrays(
            expected: expectedOutput,
            actual: actualOutput,
            testName: testName
        )
    }

    // MARK: - Utilities

    private func loadTestData(name: String) -> [String: Any]? {
        // Try bundle resource first
        if let url = Bundle.module.url(
            forResource: name,
            withExtension: "json",
            subdirectory: "HTDemucsReference"
        ) {
            return loadJSON(from: url)
        }

        // Fall back to file path
        let path = "Tests/MetalNNTests/Resources/HTDemucsReference/\(name).json"
        let url = URL(fileURLWithPath: path)
        if FileManager.default.fileExists(atPath: path) {
            return loadJSON(from: url)
        }

        // Try from current working directory
        let cwdPath = FileManager.default.currentDirectoryPath
        let fullPath = "\(cwdPath)/\(path)"
        if FileManager.default.fileExists(atPath: fullPath) {
            return loadJSON(from: URL(fileURLWithPath: fullPath))
        }

        return nil
    }

    private func loadJSON(from url: URL) -> [String: Any]? {
        guard let data = try? Data(contentsOf: url),
              let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            return nil
        }
        return json
    }

    private func compareArrays(expected: [Float], actual: [Float], testName: String) {
        XCTAssertEqual(
            expected.count, actual.count,
            "\(testName): Output size mismatch - expected \(expected.count), got \(actual.count)"
        )

        var maxAbsDiff: Float = 0
        var maxRelDiff: Float = 0
        var failedCount = 0

        for i in 0..<min(expected.count, actual.count) {
            let exp = expected[i]
            let act = actual[i]
            let absDiff = abs(exp - act)
            let relDiff = abs(exp) > 1e-8 ? absDiff / abs(exp) : absDiff

            maxAbsDiff = max(maxAbsDiff, absDiff)
            maxRelDiff = max(maxRelDiff, relDiff)

            let passes = absDiff <= absoluteTolerance || relDiff <= relativeTolerance
            if !passes {
                failedCount += 1
                if failedCount <= 5 {
                    print("  [\(i)] expected=\(exp), actual=\(act), diff=\(absDiff)")
                }
            }
        }

        if failedCount > 0 {
            XCTFail("\(testName): \(failedCount)/\(expected.count) values exceed tolerance. " +
                    "maxAbsDiff=\(maxAbsDiff), maxRelDiff=\(maxRelDiff)")
        } else {
            // Log stats on success
            print("  \(testName): PASS (maxAbsDiff=\(String(format: "%.2e", maxAbsDiff)), " +
                  "maxRelDiff=\(String(format: "%.2e", maxRelDiff)))")
        }
    }
}

// MARK: - HTDemucs Validation Summary

@available(macOS 15.0, iOS 18.0, *)
final class HTDemucsAccuracySummaryTests: XCTestCase {

    func testPrintAccuracySummary() throws {
        print("\n" + String(repeating: "=", count: 60))
        print("HTDemucs PyTorch Validation Summary")
        print(String(repeating: "=", count: 60))
        print("\nRun `swift test --filter HTDemucsValidation` for results.")
        print("\nTests validate encoder blocks against PyTorch:")
        print("  - Time encoder blocks (1D): Conv1D -> GroupNorm -> GELU")
        print("  - Freq encoder blocks (2D): Conv2D -> GroupNorm -> GELU")
        print("\nActual accuracy achieved:")
        print("  Absolute: ~1e-6 (tolerance set to 1e-4)")
        print("  Relative: ~1e-3")
    }
}

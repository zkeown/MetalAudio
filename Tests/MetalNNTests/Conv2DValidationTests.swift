import XCTest
import Foundation
@testable import MetalNN
@testable import MetalAudioKit

// MARK: - Conv2D PyTorch Validation Tests

/// Validates DynamicConv2D and DynamicConvTranspose2D against PyTorch reference outputs.
///
/// Reference data is generated by `Scripts/generate_conv2d_reference.py`.
/// Each test loads a JSON file with input, weights, and expected output from PyTorch,
/// then compares our Metal implementation against it.
@available(macOS 15.0, iOS 18.0, *)
final class Conv2DValidationTests: XCTestCase {

    var device: AudioDevice!
    var context: ComputeContext!

    /// Absolute tolerance for float comparison
    let absoluteTolerance: Float = 1e-4

    /// Relative tolerance for float comparison
    let relativeTolerance: Float = 1e-3

    override func setUpWithError() throws {
        device = try AudioDevice()
        context = try ComputeContext(device: device)
    }

    // MARK: - Test Cases

    func testBasic3x3NoPadding() throws {
        try runValidation(testName: "basic_3x3_no_padding")
    }

    func test3x3SamePadding() throws {
        try runValidation(testName: "3x3_same_padding")
    }

    func test3x3Stride2HTDemucs() throws {
        try runValidation(testName: "3x3_stride2_htdemucs")
    }

    func test1x1Pointwise() throws {
        try runValidation(testName: "1x1_pointwise")
    }

    func test3x3LargeChannels() throws {
        try runValidation(testName: "3x3_large_channels")
    }

    func test3x3NoBias() throws {
        try runValidation(testName: "3x3_no_bias")
    }

    func test3x3AsymmetricInput() throws {
        try runValidation(testName: "3x3_asymmetric_input")
    }

    func testConvTransposeBasic() throws {
        try runTransposeValidation(testName: "conv_transpose_basic")
    }

    func testConvTransposeHTDemucs() throws {
        try runTransposeValidation(testName: "conv_transpose_htdemucs")
    }

    func testIdentityLike() throws {
        try runValidation(testName: "identity_like")
    }

    // MARK: - Validation Logic

    private func runValidation(testName: String) throws {
        guard let testData = loadTestData(name: testName) else {
            throw XCTSkip("Reference data not found: \(testName).json")
        }

        let config = testData["config"] as! [String: Any]
        let inChannels = config["in_channels"] as! Int
        let outChannels = config["out_channels"] as! Int
        let kernelSize = config["kernel_size"] as! [Int]
        let stride = config["stride"] as! [Int]
        let padding = config["padding"] as! [Int]
        let hasBias = config["bias"] as! Bool

        let inputShape = testData["input_shape"] as! [Int]
        let inputData = (testData["input"] as! [Double]).map { Float($0) }
        let weightData = (testData["weight"] as! [Double]).map { Float($0) }
        let expectedOutput = (testData["output"] as! [Double]).map { Float($0) }
        let biasData: [Float]? = hasBias
            ? (testData["bias"] as! [Double]).map { Float($0) }
            : nil

        // Create Conv2D layer
        let conv = try DynamicConv2D(
            device: device,
            inputChannels: inChannels,
            outputChannels: outChannels,
            kernelSize: (height: kernelSize[0], width: kernelSize[1]),
            stride: (height: stride[0], width: stride[1]),
            paddingMode: .explicit(h: padding[0], w: padding[1]),
            useBias: hasBias
        )

        // Load weights
        try conv.loadWeights(weightData, bias: biasData)

        // Create input tensor
        let input = try Tensor(device: device, shape: inputShape)
        try input.copy(from: inputData)

        // Run forward pass
        var output: Tensor?
        try context.executeSync { encoder in
            output = try conv.forward(input: input, encoder: encoder)
        }

        // Compare output
        let actualOutput = output!.toArray()
        compareArrays(
            expected: expectedOutput,
            actual: actualOutput,
            testName: testName
        )
    }

    private func runTransposeValidation(testName: String) throws {
        guard let testData = loadTestData(name: testName) else {
            throw XCTSkip("Reference data not found: \(testName).json")
        }

        let config = testData["config"] as! [String: Any]
        let inChannels = config["in_channels"] as! Int
        let outChannels = config["out_channels"] as! Int
        let kernelSize = config["kernel_size"] as! [Int]
        let stride = config["stride"] as! [Int]
        let padding = config["padding"] as! [Int]
        let outputPadding = config["output_padding"] as! [Int]
        let hasBias = config["bias"] as! Bool

        let inputShape = testData["input_shape"] as! [Int]
        let inputData = (testData["input"] as! [Double]).map { Float($0) }
        let weightData = (testData["weight"] as! [Double]).map { Float($0) }
        let expectedOutput = (testData["output"] as! [Double]).map { Float($0) }
        let biasData: [Float]? = hasBias
            ? (testData["bias"] as! [Double]).map { Float($0) }
            : nil

        // Create ConvTranspose2D layer
        let convTranspose = try DynamicConvTranspose2D(
            device: device,
            inputChannels: inChannels,
            outputChannels: outChannels,
            kernelSize: (height: kernelSize[0], width: kernelSize[1]),
            stride: (height: stride[0], width: stride[1]),
            padding: (height: padding[0], width: padding[1]),
            outputPadding: (height: outputPadding[0], width: outputPadding[1])
        )

        // Load weights
        try convTranspose.loadWeights(weightData, bias: biasData)

        // Create input tensor
        let input = try Tensor(device: device, shape: inputShape)
        try input.copy(from: inputData)

        // Run forward pass
        var output: Tensor?
        try context.executeSync { encoder in
            output = try convTranspose.forward(input: input, encoder: encoder)
        }

        // Compare output
        let actualOutput = output!.toArray()
        compareArrays(
            expected: expectedOutput,
            actual: actualOutput,
            testName: testName
        )
    }

    // MARK: - Utilities

    private func loadTestData(name: String) -> [String: Any]? {
        // Try bundle resource first
        if let url = Bundle.module.url(
            forResource: name,
            withExtension: "json",
            subdirectory: "Conv2DReference"
        ) {
            return loadJSON(from: url)
        }

        // Fall back to file path
        let path = "Tests/MetalNNTests/Resources/Conv2DReference/\(name).json"
        let url = URL(fileURLWithPath: path)
        if FileManager.default.fileExists(atPath: path) {
            return loadJSON(from: url)
        }

        // Try from current working directory
        let cwdPath = FileManager.default.currentDirectoryPath
        let fullPath = "\(cwdPath)/\(path)"
        if FileManager.default.fileExists(atPath: fullPath) {
            return loadJSON(from: URL(fileURLWithPath: fullPath))
        }

        return nil
    }

    private func loadJSON(from url: URL) -> [String: Any]? {
        guard let data = try? Data(contentsOf: url),
              let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            return nil
        }
        return json
    }

    private func compareArrays(expected: [Float], actual: [Float], testName: String) {
        XCTAssertEqual(
            expected.count, actual.count,
            "\(testName): Output size mismatch - expected \(expected.count), got \(actual.count)"
        )

        var maxAbsDiff: Float = 0
        var maxRelDiff: Float = 0
        var failedCount = 0

        for i in 0..<min(expected.count, actual.count) {
            let exp = expected[i]
            let act = actual[i]
            let absDiff = abs(exp - act)
            let relDiff = abs(exp) > 1e-8 ? absDiff / abs(exp) : absDiff

            maxAbsDiff = max(maxAbsDiff, absDiff)
            maxRelDiff = max(maxRelDiff, relDiff)

            let passes = absDiff <= absoluteTolerance || relDiff <= relativeTolerance
            if !passes {
                failedCount += 1
                if failedCount <= 5 {
                    print("  [\(i)] expected=\(exp), actual=\(act), diff=\(absDiff)")
                }
            }
        }

        if failedCount > 0 {
            XCTFail("\(testName): \(failedCount)/\(expected.count) values exceed tolerance. " +
                    "maxAbsDiff=\(maxAbsDiff), maxRelDiff=\(maxRelDiff)")
        } else {
            // Log stats on success
            print("  \(testName): PASS (maxAbsDiff=\(String(format: "%.2e", maxAbsDiff)), " +
                  "maxRelDiff=\(String(format: "%.2e", maxRelDiff)))")
        }
    }
}

// MARK: - Numerical Accuracy Summary Test

@available(macOS 15.0, iOS 18.0, *)
final class Conv2DAccuracySummaryTests: XCTestCase {

    func testPrintAccuracySummary() throws {
        print("\n" + String(repeating: "=", count: 60))
        print("Conv2D PyTorch Validation Summary")
        print(String(repeating: "=", count: 60))
        print("\nRun `swift test --filter Conv2DValidation` to see detailed results.")
        print("\nExpected tolerances:")
        print("  Absolute: 1e-4")
        print("  Relative: 1e-3")
        print("\nThese tolerances account for:")
        print("  - Float32 precision differences")
        print("  - GPU vs CPU numerical variations")
        print("  - Different accumulation orders")
    }
}
